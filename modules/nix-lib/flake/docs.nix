# nix-lib docs generation module
#
# Generates markdown documentation for all defined libs.
# Available at perSystem.nix-lib.docs.package derivation.
#
# Usage:
#   nix build .#nix-lib-docs  # Builds markdown documentation (when enableOutput = true)
#
# Configuration:
#   nix-lib.docs.package      - The documentation derivation
#   nix-lib.docs.enableOutput - Export as packages.nix-lib-docs (default: true)
#
{ lib, config, ... }:
let
  libDefTypeModule = import ../_lib/libDefType.nix { inherit lib; };
  inherit (libDefTypeModule) flattenLibs libDefsToMeta;

  # Get flake-level lib metadata
  flakeLibsMeta = config.nix-lib._flakeLibsMeta or { };

  # Get collected metadata from all module systems
  collectedMeta = lib.mapAttrs (_: collector: collector config) (
    config.nix-lib.metaCollectors or { }
  );

  # Flatten all collected metadata
  allCollectedMeta = lib.foldl' (acc: meta: acc // meta) { } (lib.attrValues collectedMeta);

  # All flake-level metadata (flake libs + collected from nixos/home/etc)
  allFlakeMeta = flakeLibsMeta // allCollectedMeta;

  # Generate markdown anchor from lib name
  nameToAnchor = name: builtins.replaceStrings [ "." ] [ "-" ] name;

  # Generate index entry for a single lib
  libToIndexEntry =
    name: meta:
    let
      anchor = nameToAnchor name;
      fileLink = if meta.file or null != null then " ([source](${meta.file}))" else "";
    in
    "- [`${name}`](#${anchor})${fileLink}";

  # Generate markdown for a single lib
  libToMarkdown =
    name: meta:
    let
      anchor = nameToAnchor name;
      visibleStr = if meta.visible or true then "" else " *(private)*";
      descStr = meta.description or "No description";
      testCount = builtins.length (builtins.attrNames (meta.tests or { }));
      testsStr = if testCount > 0 then " (${toString testCount} tests)" else "";
      fileStr =
        if meta.file or null != null then
          ''

            **Source:** [${meta.file}](${meta.file})
          ''
        else
          "";
      exampleStr =
        if meta.example or null != null then
          ''

            **Example:**
            ```nix
            ${meta.example}
            ```
          ''
        else
          "";
    in
    ''
      ### `${name}` {#${anchor}}${visibleStr}

      ${descStr}${testsStr}
      ${fileStr}${exampleStr}
    '';
in
{
  perSystem =
    {
      pkgs,
      config,
      ...
    }:
    let
      cfg = config.nix-lib.docs;

      # Get per-system lib metadata
      perSystemLibDefs = flattenLibs "" (config.nix-lib.lib or { });
      perSystemLibsMeta = libDefsToMeta perSystemLibDefs (config.lib or { });

      # Merge flake metadata (from closure) with per-system metadata
      allLibsMeta = allFlakeMeta // perSystemLibsMeta;

      # Sort all libs alphabetically
      allSortedLibNames = builtins.sort (a: b: a < b) (builtins.attrNames allLibsMeta);

      # Generate full markdown document including per-system libs
      generateMarkdown =
        let
          indexEntries = lib.concatMapStringsSep "\n" (
            name: libToIndexEntry name allLibsMeta.${name}
          ) allSortedLibNames;
          libDocs = lib.concatMapStrings (name: libToMarkdown name allLibsMeta.${name}) allSortedLibNames;
          libCount = builtins.length allSortedLibNames;
        in
        ''
          # nix-lib API Reference

          Generated documentation for all defined library functions.

          **Total libs:** ${toString libCount}

          ## Index

          ${indexEntries}

          ## Libraries

          ${libDocs}
          ---

          *Generated by nix-lib*
        '';

      # Create the derivation
      docsDerivation = pkgs.writeTextFile {
        name = "nix-lib-docs";
        text = generateMarkdown;
        destination = "/docs.md";
      };
    in
    {
      options.nix-lib.docs = {
        package = lib.mkOption {
          type = lib.types.package;
          default = docsDerivation;
          description = ''
            Markdown documentation package for all defined libs.

            The output contains a `docs.md` file with all lib definitions.
          '';
        };

        enableOutput = lib.mkOption {
          type = lib.types.bool;
          default = true;
          description = ''
            Whether to export the docs package as `packages.nix-lib-docs`.

            When enabled, you can build with:
            ```
            nix build .#nix-lib-docs
            ```
          '';
        };
      };

      # Export as package when enabled
      config.packages = lib.mkIf cfg.enableOutput {
        nix-lib-docs = cfg.package;
      };
    };
}
